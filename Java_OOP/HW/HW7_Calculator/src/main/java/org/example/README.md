### О реализации принципов ООП
1) **Наследование:**  
   Теоретически, наследованием можно посчитать имплементацию классами интерфейсов :)
_______________
2) **Инкапсуляция:**  
Самое простое: в классе ComplexNumber реальные и мнимые части комплексного числа можно задать, 
только при создании комлексного числа, впоследствии поменять их нельзя. А так в приниципе, где доступа к переменным не должно быть - его и нет. 
_______________
3) **Полиморфизм:**  
Не пригодился. 
_______________
_______________

### О реализации принципов SOLID

1. **Single Responsibility Principle:**  
Например, есть отдельные классы, для создания комплексных чисел, совершения операций с ними,
логгирования. 
_______________
2. **Open Closed Principle:**   
Реализован, например, в классе Calculator, который можно расширять
передавая в его конструктор новые операции при создании экземпляра класса. 
Изменять сам код класса при этом не надо. 
_______________
3. **Liskov’s Substitution Principle:**  
Не пригодился.   
_______________
4. **Interface Segregation Principle:**  
Каждый из интерфейсов реализует только те методы, которые нужны. "Лишних" методов нет :)
________________
5. **Dependency Inversion Principle:**
Например, Calculator принимает в себя интерфейсы (ILogger), взаимодействует с интерфейсами, 
при создании списков операций (ArrayList<IOperation> availableOperations).  
Нарушением этого принципа было бы инициализировать экземпляры этих классов внутри, использовать их
_______________
_______________

### Об использовании паттернов проектирования
Использован паттерн "команда". *Класс-отправитель* - Controller, *команды* - операции с комплексным числами
*получалель* - объект класса Калькулятор, а *клиентом* выступает метод start(), который создает Controller 
и через который определяется, какие операции над комплексными числами будут совершаться