#### Дисклеймер: 
1) Учитывая количество классов, я в этом файле опишу реализацию принципов SOLID
2) исходим из того, что у нас идеальный пользователь, который не вводит несуществующих айдишников,
неподходящих символов и т.п.;
2) а еще я не стала описывать каждый метод;
3) я узнала, что в Java интерфейсы именуются иначе, чем я это сделала, уже когда писала это описание.   
Буду уже иметь в виду на будущее. 

### О реализации принципов SOLID

1. **Single Responsibility Principle:**  
Например, класс AnimalStorage отвечает за основные операции, связанные с хранением животных.   
При этом процедуры с животными, выделены в отдельные классы, имплементирующие интерфейсы IProcedure 
и IProcedureRepeatable.   
Также есть отдельные классы Animal и Dog, которые хранят информацию о животных.
_______________
2. **Open Closed Principle:**   
Реализован, например в классе Shelter, который можно расширять
передавая в его конструктор новые операции при создании экземпляра класса Shelter и дописывая новые методы. 
Изменять сам код класса при этом не надо. 
_______________
3. **Liskov’s Substitution Principle:**  
Реализован, например, в рамках класса ProcedureBase - это абстрактный класс, предполагающий возможность создать
процедуру в отношении животного. У него есть класс-наследник Castration (предполагающий разовую процедуру).  
А еще есть классы-наследники Vaccination и AntiParasitesTreatment, которые реализуют интерфейс IRepeatableProcedures.  
Эти классы-наследники расширяют класс ProcedureBase - содержат новую переменную (дата повторной обработки) и доп.метод.  
_______________
4. **Interface Segregation Principle:**  
Есть интерфейс IProcedure, наследником которого является IRepeatableProcedure.  
Наследник отличается одним методом - getDateOfNextProcedure(). Это интерфейс, который будут имплементировать классы,
предполагающие повторную обработку живности. Но этот метод не нужен, например, для класса Castration.
________________
5. **Dependency Inversion Principle:**
Например, Shelter принимает в себя интерфейсы (IAnimalStorage), взаимодействует с интерфейсами, 
при создании списков процедур (ArrayList<IProcedure> availableProcedures).  
Нарушением этого принципа было бы инициализировать экземпляры этих классов внутри, использовать их